fof(reflexive, axiom, ((
	![X:$int]:
	X = X))).

fof(symmetric, axiom, ((
	![X:$int,Y:$int]:(
	X = Y
	=> Y = X)))).

fof(transitive, axiom, ((
	![A:$int,B:$int,C:$int]:(
	A = B
	& B = C
	=> A = C)))).

fof(substitution_add, axiom, ((	
	![A:$int,B:$int,C:$int,D:$int]:(
	A = B
	& C = D
	& E = $sum(A,C)
	& F = $sum(B,D)
	=> E = F)))).

fof(substitution_mult, axiom, ((
	! [A:$int,B:$int,C:$int,D:$int,E:$int,F:$int]:
	(A = B
	& C = D
	& E = $product(A,C)
	& F = $product(B,D)
	=> E = F)))).

fof(multIdentity, axiom, ((
	![X:$int]:(
	?[_1:$int]:(
	X = $product(_1,X)))))).	

fof(addIdentity, axiom, ((
	![X:$int]:(
	?[_0:$int]:(
	X = $sum(_0,X)))))).	


fof(addSymm, axiom, ((
	![X:$int,Y:$int]:(
	sum(X, Y)
	=> sum(Y, X))))).

fof(multSymm, axiom, ((
	![X:$int,Y:$int]:(
	$product(X, Y)
	=> $product(Y, X))))).

%additive inverses

%Cancellation - AC = BC => A = B as long as C != 0

%If using any sort of quantifier, parens for everything!!
fof(test, conjecture, ((
	! [A:$int,B:$int,C:$int,D:$int,E:$int,F:$int]:
	((A = C & B = D & E = $product(A,B) & F = $product(C,D) => E = F))))).
